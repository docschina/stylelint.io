{"head":{"description":"编写插件 插件是社区构建的规则和规则集 我们建议您熟悉并遵守 stylelint 的规则编写约定，包括命名、选项、消息、测试和文档。 插件详解 您的插件规则名必须有命名空间，例如…","title":"编写插件"},"body":"<h1 id=\"编写插件\"><a href=\"#%E7%BC%96%E5%86%99%E6%8F%92%E4%BB%B6\" class=\"phenomic-HeadingAnchor\">#</a>编写插件</h1>\n<p>插件是社区构建的规则和规则集</p>\n<p>我们建议您熟悉并遵守 stylelint 的<a href=\"../rules/\">规则编写约定</a>，包括命名、选项、消息、测试和文档。</p>\n<ul>\n<li>\n<p><a href=\"#%E6%8F%92%E4%BB%B6%E8%AF%A6%E8%A7%A3\">插件详解</a></p>\n<ul>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E8%A7%84%E5%88%99\">异步规则</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#stylelintutils\">stylelint.utils</a></p>\n<ul>\n<li><a href=\"#stylelintutilsreport\">stylelint.utils.report</a></li>\n<li><a href=\"#stylelintutilsrulemessages\">stylelint.utils.ruleMessages</a></li>\n<li><a href=\"#stylelintutilsvalidateoptions\">stylelint.utils.validateOptions</a></li>\n<li><a href=\"#stylelintutilscheckagainstrule\">stylelint.utils.checkAgainstRule</a></li>\n</ul>\n</li>\n<li><a href=\"#stylelintrules\">stylelint.rules</a></li>\n<li><a href=\"#%E5%85%81%E8%AE%B8%E4%B8%BB%E9%80%89%E9%A1%B9%E6%95%B0%E7%BB%84\">允许主选项数组</a></li>\n<li><a href=\"#%E5%A4%96%E9%83%A8%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97\">外部辅助模块</a></li>\n<li><a href=\"#%E5%AF%B9%E7%AD%89%E4%BE%9D%E8%B5%96\">对等依赖</a></li>\n<li><a href=\"#%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6\">测试插件</a></li>\n<li><a href=\"#%E6%8F%92%E4%BB%B6%E5%8C%85\">插件包</a></li>\n<li><a href=\"#%E5%85%B1%E4%BA%AB%E6%8F%92%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E5%8C%85\">共享插件和插件包</a></li>\n</ul>\n<h2 id=\"插件详解\"><a href=\"#%E6%8F%92%E4%BB%B6%E8%AF%A6%E8%A7%A3\" class=\"phenomic-HeadingAnchor\">#</a>插件详解</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 简短的例子</span>\n<span class=\"hljs-keyword\">var</span> stylelint = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"stylelint\"</span>)\n\n<span class=\"hljs-keyword\">var</span> ruleName = <span class=\"hljs-string\">\"plugin/foo-bar\"</span>\n<span class=\"hljs-keyword\">var</span> messages =  stylelint.utils.ruleMessages(ruleName, {\n  <span class=\"hljs-attr\">expected</span>: <span class=\"hljs-string\">\"Expected ...\"</span>,\n})\n\n<span class=\"hljs-built_in\">module</span>.exports = stylelint.createPlugin(ruleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">primaryOption, secondaryOptionObject</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">postcssRoot, postcssResult</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> validOptions = stylelint.utils.validateOptions(postcssResult, ruleName, { .. })\n    <span class=\"hljs-keyword\">if</span> (!validOptions) { <span class=\"hljs-keyword\">return</span> }\n    <span class=\"hljs-comment\">// ... 一些逻辑 ...</span>\n    stylelint.utils.report({ .. })\n  }\n})\n\n<span class=\"hljs-built_in\">module</span>.exports.ruleName = ruleName\n<span class=\"hljs-built_in\">module</span>.exports.messages = messages</code></pre>\n<p>您的插件规则名必须有命名空间，例如 <code>your-namespace/your-rule-name</code>。如果您的插件只提供一个单独的规则或您想不出一个好的命名空间，您可以简单地使用 <code>plugin/my-rule</code>。此命名空间可确保插件规则永远不会与核心规则冲突。<em>请确保您的文档里面记录了插件的规则名（和命名空间），因为用户需要在配置中使用它。</em></p>\n<p><code>stylelint.createPlugin(ruleName, ruleFunction)</code> 可确保您的插件能与其他规则一起正确设定。</p>\n<p>为了使插件规则能够使用<a href=\"../../user-guide/configuration/#rules\">标准配置格式</a>，<code>ruleFunction</code> 应该接受两个参数：主选项和可选辅助选项对象。</p>\n<p>如果您的插件规则支持<a href=\"../rules/#%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D\">自动修复</a>，则 <code>ruleFunction</code> 还应接受第三个参数：context。此外，强烈建议您在辅助选项对象中支持 <code>disableFix</code> 选项。如果用户为规则传递 <code>disableFix</code> 选项，则不在规则内执行自动修复。</p>\n<p><code>ruleFunction</code> 可以返回一个函数，这个函数本质上是一个小的 <a href=\"https://github.com/postcss/postcss/blob/master/docs/writing-a-plugin.md\">PostCSS 插件</a>：它接受两个参数：PostCSS Root（解析的 AST）和 PostCSS LazyResult。您必须<a href=\"https://api.postcss.org/\">了解 PostCSS 应用程序接口</a>。</p>\n<h3 id=\"异步规则\"><a href=\"#%E5%BC%82%E6%AD%A5%E8%A7%84%E5%88%99\" class=\"phenomic-HeadingAnchor\">#</a>异步规则</h3>\n<p>规则使用异步 PostCSS 插件也是可行的！您需要做的就是从插件函数返回一个 Promise 实例。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 简短的异步例子</span>\n<span class=\"hljs-keyword\">var</span> stylelint = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"stylelint\"</span>)\n\n<span class=\"hljs-keyword\">var</span> ruleName = <span class=\"hljs-string\">\"plugin/foo-bar-async\"</span>\n<span class=\"hljs-keyword\">var</span> messages =  stylelint.utils.ruleMessages(ruleName, {\n  <span class=\"hljs-attr\">expected</span>: <span class=\"hljs-string\">\"Expected ...\"</span>,\n})\n\n<span class=\"hljs-built_in\">module</span>.exports = stylelint.createPlugin(ruleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">primaryOption, secondaryOptionObject</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">postcssRoot, postcssResult</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> validOptions = stylelint.utils.validateOptions(postcssResult, ruleName, { .. })\n    <span class=\"hljs-keyword\">if</span> (!validOptions) { <span class=\"hljs-keyword\">return</span> }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve</span>) </span>{\n      <span class=\"hljs-comment\">// 一些异步操作</span>\n      setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-comment\">// ... 一些逻辑 ...</span>\n        stylelint.utils.report({ .. })\n        resolve()\n      }, <span class=\"hljs-number\">1</span>)\n    })\n  }\n})\n\n<span class=\"hljs-built_in\">module</span>.exports.ruleName = ruleName\n<span class=\"hljs-built_in\">module</span>.exports.messages = messages</code></pre>\n<h2 id=\"stylelintutils\"><a href=\"#stylelintutils\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils</code></h2>\n<p>stylelint 公开了一些有用的实用程序。<em>关于这些应用程序的接口，请查看源码的注释和标准规则中的示例。</em></p>\n<h3 id=\"stylelintutilsreport\"><a href=\"#stylelintutilsreport\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.report</code></h3>\n<p>将插件中的违规添加到 stylelint 向用户报告的违规列表中。</p>\n<p><em>不要直接使用 PostCSS 的 <code>node.warn()</code> 方法。</em>当您使用 <code>stylelint.utils.report</code> 时，您的插件会遵守禁用范围和其他 stylelint 未来的特性。这会提供更好的用户体验，更符合标准规则。</p>\n<h3 id=\"stylelintutilsrulemessages\"><a href=\"#stylelintutilsrulemessages\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.ruleMessages</code></h3>\n<p>将您的消息定制为标准 stylelint 规则的格式。</p>\n<h3 id=\"stylelintutilsvalidateoptions\"><a href=\"#stylelintutilsvalidateoptions\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.validateOptions</code></h3>\n<p>验证您的规则选项。</p>\n<h3 id=\"stylelintutilscheckagainstrule\"><a href=\"#stylelintutilscheckagainstrule\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.utils.checkAgainstRule</code></h3>\n<p><em>在您自己的规则中</em>使用标准 stylelint 规则检查 CSS。此功能为希望修改、约束或扩展现有 stylelint 规则功能的插件作者提供了强大功能和灵活性。</p>\n<p>接受选项对象和用于接收来自被调用规则的警告的回调。选项是：</p>\n<ul>\n<li><code>ruleName</code>: 要调用的规则的名称。</li>\n<li><code>ruleSettings</code>: 您正在调用的规则的设置，格式与 <code>.stylelintrc</code> 配置对象中的格式相同。</li>\n<li><code>root</code>: 针对此规则运行的根节点。</li>\n</ul>\n<p>使用警告来创建一个<em>来自您插件规则</em>的<em>新</em>警告，并用 <code>stylelint.utils.report</code> 汇报</p>\n<p>比如，假设您要创建一个插件，使用您的预处理器内置的@规则的例外列表来运行 <code>at-rule-no-unknown</code>：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> allowableAtRules = [..]\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPluginRule</span>(<span class=\"hljs-params\">primaryOption, secondaryOptions</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">root, result</span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> defaultedOptions = <span class=\"hljs-built_in\">Object</span>.assign({}, secondaryOptions, {\n      <span class=\"hljs-attr\">ignoreAtRules</span>: allowableAtRules.concat(options.ignoreAtRules || []),\n    })\n\n    stylelint.utils.checkAgainstRule({\n      <span class=\"hljs-attr\">ruleName</span>: <span class=\"hljs-string\">'at-rule-no-unknown'</span>,\n      <span class=\"hljs-attr\">ruleSettings</span>: [primaryOption, defaultedOptions],\n      <span class=\"hljs-attr\">root</span>: root\n    }, (warning) => {\n      stylelint.utils.report({\n        <span class=\"hljs-attr\">message</span>: myMessage,\n        <span class=\"hljs-attr\">ruleName</span>: myRuleName,\n        <span class=\"hljs-attr\">result</span>: result,\n        <span class=\"hljs-attr\">node</span>: warning.node,\n        <span class=\"hljs-attr\">line</span>: warning.line,\n        <span class=\"hljs-attr\">column</span>: warning.column,\n      })\n    })\n  }\n}</code></pre>\n<h2 id=\"stylelintrules\"><a href=\"#stylelintrules\" class=\"phenomic-HeadingAnchor\">#</a><code>stylelint.rules</code></h2>\n<p>所有规则函数都可以在 <code>stylelint.rules</code> 中找到。这使您可以根据您的特定需求构建现有规则。</p>\n<p>一个典型的用例是，在复杂条件下构建规则选项。例如，您的代码库可能使用特殊注释指令来自定义特定样式表的规则选项。您可以构建一个插件来检查这些指令，然后使用正确的选项运行适当的规则（或者根本不运行它们）。</p>\n<p>所有规则都有共同的签名。它们是一个接受两个参数的函数：主选项和辅助选项对象。并且该函数返回一个具有 PostCSS 插件签名的函数，期望PostCSS 根节点和结果作为其参数。</p>\n<p>这里有个简短的例子，只有当样式表某处有个特殊的指令 <code>@@check-color-hex-case</code> 时才运行 <code>color-hex-case</code>。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> stylelint.createPlugin(ruleName, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">expectation</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> runColorHexCase = stylelint.rules[<span class=\"hljs-string\">\"color-hex-case\"</span>](expectation)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">root, result</span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (root.toString().indexOf(<span class=\"hljs-string\">\"@@check-color-hex-case\"</span>) === <span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span>\n    runColorHexCase(root, result)\n  }\n})</code></pre>\n<h2 id=\"允许主选项数组\"><a href=\"#%E5%85%81%E8%AE%B8%E4%B8%BB%E9%80%89%E9%A1%B9%E6%95%B0%E7%BB%84\" class=\"phenomic-HeadingAnchor\">#</a>允许主选项数组</h2>\n<p>如果您的插件可以接受数组作为其主选项，则必须通过在规则函数上设置属性 <code>primaryOptionArray = true</code> 来指定它。有关更多信息，请查看<a href=\"../rules/#%E4%B8%BB%E9%80%89%E9%A1%B9\">“处理规则”</a>文档。</p>\n<h2 id=\"外部辅助模块\"><a href=\"#%E5%A4%96%E9%83%A8%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97\" class=\"phenomic-HeadingAnchor\">#</a>外部辅助模块</h2>\n<p>除了<a href=\"../rules/\">“处理规则”</a>文档中提到的标准解析器, 我们还推荐使用在 stylelint 里用到的其他的外部模块。它们包括:</p>\n<ul>\n<li><a href=\"https://github.com/getify/normalize-selector\">normalize-selector</a>：规范化CSS选择器。</li>\n<li><a href=\"https://github.com/davidtheclark/postcss-resolve-nested-selector\">postcss-resolve-nested-selector</a>：给予 PostCSS AST 中的（嵌套）选择器，返回解析后的选择器的数组。</li>\n<li><a href=\"https://github.com/davidtheclark/style-search\">style-search</a>：搜索CSS（和类 CSS）中的字符串，对字符串、注释和函数内是否发生匹配敏感。</li>\n</ul>\n<p>请看一下 <a href=\"https://github.com/stylelint/stylelint/tree/master/lib/utils\">stylelint 的内部工具</a>，如果您遇到一个您的插件需要的函数，请考虑帮助我们把它提取为外部模块。</p>\n<h2 id=\"对等依赖\"><a href=\"#%E5%AF%B9%E7%AD%89%E4%BE%9D%E8%B5%96\" class=\"phenomic-HeadingAnchor\">#</a>对等依赖</h2>\n<p>您应该在插件的 <code>package.json</code> 的 <code>peerDependencies</code>（<strong>不是</strong> <code>dependencies</code>）键中表明，您的插件可以使用什么版本的 stylelint。这是为了确保不会安装非预期的 stylelint 版本。</p>\n<p>例如，要表示您的插件可以与 stylelint 版本 7 和 8 一起使用：</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"peerDependencies\"</span>: {\n    <span class=\"hljs-attr\">\"stylelint\"</span>: <span class=\"hljs-string\">\"^7.0.0 || ^8.0.0\"</span>\n  }\n}</code></pre>\n<h2 id=\"测试插件\"><a href=\"#%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6\" class=\"phenomic-HeadingAnchor\">#</a>测试插件</h2>\n<p>为了测试您的插件，您可以考虑使用和 stylelint 内部使用的一样的规则测试函数，: <a href=\"https://github.com/stylelint/stylelint-test-rule-tape\"><code>stylelint-test-rule-tape</code></a>。</p>\n<h2 id=\"插件包\"><a href=\"#%E6%8F%92%E4%BB%B6%E5%8C%85\" class=\"phenomic-HeadingAnchor\">#</a>插件包</h2>\n<p>要使单个模块提供多个规则，只需导出一个插件对象数组（而不是单个对象）。</p>\n<h2 id=\"共享插件和插件包\"><a href=\"#%E5%85%B1%E4%BA%AB%E6%8F%92%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E5%8C%85\" class=\"phenomic-HeadingAnchor\">#</a>共享插件和插件包</h2>\n<ul>\n<li>在您的 <code>package.json</code> 文件中使用 <code>stylelint-plugin</code> 关键字。</li>\n<li>一旦您的插件发布，请发送一个拉取请求将您的插件添加到<a href=\"../../user-guide/plugins/\">列表</a>。</li>\n</ul>\n","__filename":"developer-guide/plugins.md","__url":"/developer-guide/plugins/","__resourceUrl":"/developer-guide/plugins/index.html","__dataUrl":"/developer-guide/plugins/index.html.477d0aa032c9a3abf3bd8c50fd2af616.json"}