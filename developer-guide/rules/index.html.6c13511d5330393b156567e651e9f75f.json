{"head":{"description":"处理规则 请帮助我们创建、增强和调试 stylelint 规则！ 创建新规则 首先，开一个问题，阐述您对新规则的想法。 通常我们会对规则的目的、名称、选项和适用性进行一些讨论。 收录标准 我们讨论规则是否符合以下以收录入 stylelint 的标准： 仅适用于标准 CSS…","title":"处理规则"},"body":"<h1 id=\"处理规则\"><a href=\"#%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99\" class=\"phenomic-HeadingAnchor\">#</a>处理规则</h1>\n<p>请帮助我们创建、增强和调试 stylelint 规则！</p>\n<ul>\n<li>\n<p><a href=\"#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%A7%84%E5%88%99\">创建新规则</a></p>\n<ul>\n<li><a href=\"#%E6%94%B6%E5%BD%95%E6%A0%87%E5%87%86\">收录标准</a></li>\n<li><a href=\"#%E4%B8%BA%E8%A7%84%E5%88%99%E5%91%BD%E5%90%8D\">为规则命名</a></li>\n<li>\n<p><a href=\"#%E7%A1%AE%E7%AB%8B%E9%80%89%E9%A1%B9\">确立选项</a></p>\n<ul>\n<li><a href=\"#%E4%B8%BB%E9%80%89%E9%A1%B9\">主选项</a></li>\n<li>\n<p><a href=\"#%E8%BE%85%E5%8A%A9%E9%80%89%E9%A1%B9\">辅助选项</a></p>\n<ul>\n<li><a href=\"#%E5%85%B3%E9%94%AE%E5%AD%97-ignore-%E5%92%8C-except\">关键字 \"ignore\" 和 \"except\"</a></li>\n<li><a href=\"#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84-ignore\">用户定义的 \"ignore*\"</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E7%A1%AE%E7%AB%8B%E8%BF%9D%E8%A7%84%E6%B6%88%E6%81%AF\">确立违规消息</a></li>\n<li><a href=\"#%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99\">编写规则</a></li>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D\">添加自动修复</a></li>\n<li>\n<p><a href=\"#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95\">编写测试</a></p>\n<ul>\n<li>\n<p><a href=\"#%E6%B8%85%E5%8D%95\">清单</a></p>\n<ul>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</a></li>\n<li><a href=\"#%E9%80%9A%E5%B8%B8%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E8%BE%B9%E7%BC%98%E6%83%85%E5%86%B5\">通常被忽视的边缘情况</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95\">运行测试</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E7%BC%96%E5%86%99%E8%87%AA%E8%BF%B0%E6%96%87%E6%A1%A3\">编写自述文档</a></p>\n<ul>\n<li><a href=\"#%E5%8D%95%E8%A1%8C%E6%8F%8F%E8%BF%B0\">单行描述</a></li>\n<li><a href=\"#%E7%A4%BA%E4%BE%8B%E6%A8%A1%E5%BC%8F\">示例模式</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AE%8C%E6%88%90%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99\">完成规则编写</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%90%91%E7%8E%B0%E6%9C%89%E8%A7%84%E5%88%99%E6%B7%BB%E5%8A%A0%E9%80%89%E9%A1%B9\">向现有规则添加选项</a></li>\n<li><a href=\"#%E4%BF%AE%E5%A4%8D%E7%8E%B0%E6%9C%89%E8%A7%84%E5%88%99%E4%B8%AD%E7%9A%84-bug\">修复现有规则中的 bug</a></li>\n<li><a href=\"#%E5%BC%83%E7%94%A8%E8%A7%84%E5%88%99\">弃用规则</a></li>\n<li><a href=\"#%E6%8F%90%E9%AB%98%E8%A7%84%E5%88%99%E7%9A%84%E6%80%A7%E8%83%BD\">提高规则的性能</a></li>\n</ul>\n<h2 id=\"创建新规则\"><a href=\"#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%A7%84%E5%88%99\" class=\"phenomic-HeadingAnchor\">#</a>创建新规则</h2>\n<p>首先，开<a href=\"https://github.com/stylelint/stylelint/issues/new\">一个问题</a>，阐述您对新规则的想法。</p>\n<p>通常我们会对规则的目的、名称、选项和适用性进行一些讨论。</p>\n<h3 id=\"收录标准\"><a href=\"#%E6%94%B6%E5%BD%95%E6%A0%87%E5%87%86\" class=\"phenomic-HeadingAnchor\">#</a>收录标准</h3>\n<p>我们讨论规则是否符合以下以收录入 stylelint 的标准：</p>\n<ul>\n<li>仅适用于标准 CSS 语法。</li>\n<li>通用性；不依赖于特定模式。</li>\n<li>具有清晰明确的完成状态。</li>\n<li>有一个单一的目的。</li>\n<li>是独立的，不依赖于其他规则。</li>\n<li>不包含与其他规则重叠的功能。</li>\n</ul>\n<p>否则，它应该是一个插件。但是插件也应该尽量遵守后三个标准。</p>\n<h3 id=\"为规则命名\"><a href=\"#%E4%B8%BA%E8%A7%84%E5%88%99%E5%91%BD%E5%90%8D\" class=\"phenomic-HeadingAnchor\">#</a>为规则命名</h3>\n<p>查看<a href=\"../../user-guide/about-rules/\">规则用户指南</a>以熟悉规则命名约定。</p>\n<p>我们一直很注重确保准确一致地命名所有规则。我们在这方面的目标是确保规则易于查找和理解，并防止我们以后想要更改命名。</p>\n<p><em>我们鼓励显式而非隐式选项来命名规则。</em> 例如 <code>color-hex-case: \"upper\"|\"lower\"</code> 而非 <code>color-hex-uppercase: \"always\"|\"never\"</code>。<code>color-hex-uppercase: \"never\"</code> <em>隐含</em>总是小写的语义，而 <code>color-hex-case: \"lower\"</code> 使语义更加<em>显式</em>。</p>\n<h3 id=\"确立选项\"><a href=\"#%E7%A1%AE%E7%AB%8B%E9%80%89%E9%A1%B9\" class=\"phenomic-HeadingAnchor\">#</a>确立选项</h3>\n<h4 id=\"主选项\"><a href=\"#%E4%B8%BB%E9%80%89%E9%A1%B9\" class=\"phenomic-HeadingAnchor\">#</a>主选项</h4>\n<p>每个规则<em>必须具有</em>一个<strong>主选项</strong>。</p>\n<ul>\n<li>在 <code>\"color-hex-case\": \"upper\"</code> 中，主选项是 <code>\"upper\"</code>。</li>\n<li>在 <code>\"indentation\": [2, { \"except\": [\"block\"] }]</code> 中，主选项是 <code>2</code>。</li>\n</ul>\n<p>如果您的规则可以接受数组作为其主要选项，则必须通过在规则函数上设置属性 <code>primaryOptionArray = true</code> 来指定它。例如：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rule</span>(<span class=\"hljs-params\">primary, secondary</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">root, result</span>) =></span> {..}\n}\nrule.primaryOptionArray = <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> rule\n<span class=\"hljs-comment\">// 或者，对于插件：stylelint.createPlugin(ruleName, rule)</span></code></pre>\n<p>这里有一点需要注意：如果您的规则接受主选项数组，则它也不能接受主选项对象。如果您希望规则接受主选项数组，您应该只允许一个数组，而不是允许各种数据结构。</p>\n<h4 id=\"辅助选项\"><a href=\"#%E8%BE%85%E5%8A%A9%E9%80%89%E9%A1%B9\" class=\"phenomic-HeadingAnchor\">#</a>辅助选项</h4>\n<p>某些规则需要额外的灵活性来解决各种用例。这些可以使用<strong>可选的辅助选项对象</strong>。</p>\n<ul>\n<li>在 <code>\"color-hex-case\": \"upper\"</code> 中，没有辅助选项对象。</li>\n<li>在 <code>\"indentation\": [2, { \"except\": [\"block\"] }]</code> 中, 辅助选项对象是 <code>{ \"except\": [\"block\"] }</code>。</li>\n</ul>\n<p>最典型的次要选项是 <code>\"ignore\": []</code> 和 <code>\"except\": []</code>；但任何数据都可以使用。</p>\n<p>如果您无需忽略或例外，规则的次要选项可以是任何内容。例如，在一些 <code>selector-*</code> 规则中使用 <code>resolveNestedSelectors: true|false</code> 来改变规则处理嵌套选择器的方式。</p>\n<h5 id=\"关键字-ignore-和-except\"><a href=\"#%E5%85%B3%E9%94%AE%E5%AD%97-ignore-%E5%92%8C-except\" class=\"phenomic-HeadingAnchor\">#</a>关键字 <code>\"ignore\"</code> 和 <code>\"except\"</code></h5>\n<p><code>\"ignore\"</code> 和 <code>\"except\"</code> 接受一组预定义的关键字选项，例如 <code>[\"relative\", \"first-nested\", \"descendant\"]</code>。</p>\n<ul>\n<li>当您希望规则简单地跳过特定模式时，请使用 <code>\"ignore\"</code>。</li>\n<li>当您想要反转特定模式的主要选项时，请使用 <code>\"except\"</code>。</li>\n</ul>\n<h5 id=\"用户定义的-ignore\"><a href=\"#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84-ignore\" class=\"phenomic-HeadingAnchor\">#</a>用户定义的 <code>\"ignore*\"</code></h5>\n<p>在接受<em>用户定义的</em>要忽略的事物列表时，请使用更具体的辅助选项名称。这采取 <code>\"ignore&#x3C;Things>\": []</code>，例如如果规则检查@规则并且您想允许用户通过 <code>\"ignoreAtRules\": []</code> 指定要忽略哪些特定的@规则类型。</p>\n<h3 id=\"确立违规消息\"><a href=\"#%E7%A1%AE%E7%AB%8B%E8%BF%9D%E8%A7%84%E6%B6%88%E6%81%AF\" class=\"phenomic-HeadingAnchor\">#</a>确立违规消息</h3>\n<p>消息采用以下形式之一：</p>\n<ul>\n<li>\"预期的 [某物] [在某上下文]\"</li>\n<li>\"非预期的 [某物] [在某上下文]\"</li>\n</ul>\n<p>查看其他规则的消息，以了解更多的约定和模式。</p>\n<h3 id=\"编写规则\"><a href=\"#%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99\" class=\"phenomic-HeadingAnchor\">#</a>编写规则</h3>\n<p><em>在编写规则时，请始终查看其他类似规则的约定和模式，以便从模仿开始。</em></p>\n<p>您将使用简单的 <a href=\"https://api.postcss.org/\">PostCSS 应用程序接口</a>来导航和分析 CSS 语法树。我们建议使用 <code>walk</code> 迭代器（例如 <code>walkDecls</code>），而不是使用 <code>forEach</code> 来遍历节点。</p>\n<p>根据规则不同，我们还建议使用 <a href=\"https://github.com/TrySound/postcss-value-parser\">postcss-value-parser</a> 和 <a href=\"https://github.com/postcss/postcss-selector-parser\">postcss-selector-parser</a>。使用这些解析器而不是正则表达式或 <code>indexOf</code> 搜索有很多好处（即使它们并不总是最高效的方法）。</p>\n<p>stylelint 有许多<a href=\"https://github.com/stylelint/stylelint/tree/master/lib/utils\">实用函数</a>，它们在现有规则中使用，也可能对您有用。请仔细查看，以便了解可用的内容。（如果您有一个您认为可能通用的新功能，那么让我们把它添加到列表中！）。您肯定希望使用 <code>validateOptions()</code>，以便警告用户无效选项。（查看其他规则的选项验证示例将有很大帮助。） 您还应该使用 <code>isStandardSyntax*</code> 实用程序来忽略非标准语法。</p>\n<p><em>默认情况下</em>, 规则应更严格。用户可以通过使用 <code>\"ignore*:\"</code> 辅助选项使规则更加宽松。</p>\n<p>规则不应包含方法论或语言扩展的代码。相反，提供通用的辅助选项，以便用户可以在<em>配置级别</em>忽略这些选项。例如，在处理优先级时，规则不应该考虑 <code>:global</code> 和 <code>:local</code> 伪类（在 CSS 模块语言扩展中引入），而规则应该提供 <code>ignorePseudoClasses: []</code> 辅助选项。方法论来的快，去得也快，这种实践可以确保代码库不会被过时的代码所困扰。</p>\n<p>仅在规则处理有实际用例<em>需求</em>时才添加选项。如果没有需求，即便是为了保持一致性，也不要为规则添加选项。这是为了避免未使用的功能污染工具。</p>\n<h3 id=\"添加自动修复\"><a href=\"#%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D\" class=\"phenomic-HeadingAnchor\">#</a>添加自动修复</h3>\n<p>根据规则不同，可以通过使用 <a href=\"http://api.postcss.org/\">PostCSS 应用程序接口</a>改变 PostCSS AST（抽象语法树）来自动修复违规。</p>\n<p>将 <code>context</code> 变量添加到规则参数：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rule</span>(<span class=\"hljs-params\">primary, secondary, context</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">root, result</span>) =></span> {..}\n}</code></pre>\n<p><code>context</code> 是一个可以有两个属性的对象：</p>\n<ul>\n<li><code>fix</code>(boolean)：如果为 <code>true</code>，您的规则可以应用自动修复。</li>\n<li><code>newline</code>(string)：当前检查的文件中使用的换行符。</li>\n</ul>\n<p>如果 <code>context.fix</code> 为 <code>true</code>，那么使用 PostCSS 应用程序接口更改 <code>root</code> 并在调用 <code>report()</code> 之前返回。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (context.fix) {\n  <span class=\"hljs-comment\">// 使用 PostCSS 应用程序接口应用修复</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 返回并且不报告问题</span>\n}\n\nreport(...)</code></pre>\n<h3 id=\"编写测试\"><a href=\"#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95\" class=\"phenomic-HeadingAnchor\">#</a>编写测试</h3>\n<p>每条规则必须附带包含以下内容的测试：</p>\n<ul>\n<li>所有被视为违规的模式。</li>\n<li>所有应该<em>不</em>被视为违规的模式。</li>\n</ul>\n<p>编写 stylelint 测试很容易，所以请<em>尽可能多地编写</em>。</p>\n<h4 id=\"清单\"><a href=\"#%E6%B8%85%E5%8D%95\" class=\"phenomic-HeadingAnchor\">#</a>清单</h4>\n<p>请仔细检查此清单，确保测试涵盖每个点。特别是<em>考虑边缘情况</em>。这些都是规则中总是出现 bug 和缺点的地方。</p>\n<h5 id=\"最佳实践\"><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" class=\"phenomic-HeadingAnchor\">#</a>最佳实践</h5>\n<ul>\n<li>确保您在多个位置测试错误，而不是每次都在同一个位置。</li>\n<li>确保使用真实的（如果简单的）CSS，并避免使用省略号。</li>\n<li>确保默认使用标准 CSS 语法，并且在测试特定的非标准语法时仅交换解析器。</li>\n<li>从 PostCSS AST 访问原始字符串时，使用 <code>node.raws</code> 而不是 <code>node.raw()</code>。这将确保字符串与原始字符串完全对应。</li>\n</ul>\n<h5 id=\"通常被忽视的边缘情况\"><a href=\"#%E9%80%9A%E5%B8%B8%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E8%BE%B9%E7%BC%98%E6%83%85%E5%86%B5\" class=\"phenomic-HeadingAnchor\">#</a>通常被忽视的边缘情况</h5>\n<ul>\n<li>您的规则如何处理变量（<code>$sass</code>、<code>@less</code> 或 <code>var(--custom-property)</code>）？</li>\n<li>您的规则如何处理 CSS 字符串（例如 <code>content: \"anything goes\";</code>）？</li>\n<li>您的规则如何处理 CSS 注释（例如 <code>/* anything goes */</code>）？</li>\n<li>您的规则如何处理 <code>url()</code> 函数, 包括 data URIs（例如 <code>url(anything/goes.jpg)</code>）？</li>\n<li>您的规则如何处理供应商前缀（例如 <code>@-webkit-keyframes name {}</code>）？</li>\n<li>您的规则如何处理字母大小写（例如 <code>@KEYFRAMES name {}</code>）？</li>\n<li>您的规则如何处理伪类与伪元素的<em>组合</em>（例如 <code>a:hover::before</code>）？</li>\n<li>您的规则如何处理嵌套（例如 do you resolve <code>&#x26; a {}</code>, or check it as is?）？</li>\n<li>您的规则如何处理空白符和标点符号（例如 comparing <code>rgb(0,0,0)</code> with <code>rgb(0, 0, 0)</code>）？</li>\n</ul>\n<h4 id=\"运行测试\"><a href=\"#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95\" class=\"phenomic-HeadingAnchor\">#</a>运行测试</h4>\n<p>您可以通过以下方式运行测试：</p>\n<pre><code class=\"hljs language-console\">npm test</code></pre>\n<p>然后，这将运行所有 25,000 多个单元测试，也将检查代码。</p>\n<p>您可以使用交互式测试提示来仅针对一组选定的规则（您在开发期间要执行的操作）运行测试。例如，仅针对 <code>color-hex-case</code> 和 <code>color-hex-length</code> 规则运行测试：</p>\n<ol>\n<li>运行 <code>npm run watch</code> 以启动交互式测试提示。</li>\n<li>按 <code>p</code> 按文件名正则表达式模式过滤。</li>\n<li>输入 <code>color-hex-case|color-hex-length</code>，即每个规则名称用管道符号（<code>|</code>）分隔。</li>\n</ol>\n<h3 id=\"编写自述文档\"><a href=\"#%E7%BC%96%E5%86%99%E8%87%AA%E8%BF%B0%E6%96%87%E6%A1%A3\" class=\"phenomic-HeadingAnchor\">#</a>编写自述文档</h3>\n<p>每条规则必须附有自述文档，符合以下格式：</p>\n<ol>\n<li>规则名称。</li>\n<li>单行描述。</li>\n<li>原型代码示例。</li>\n<li>扩展描述（如有必要）。</li>\n<li>选项。</li>\n<li>被视为违规的模式示例（针对每个选项值）。</li>\n<li><em>不</em>被视为违规的模式示例（对于每个选项值）。</li>\n<li>可选选项（如适用）。</li>\n</ol>\n<p>查看其他规则的自述文件以了解更多约定模式。这些包括：</p>\n<ul>\n<li>使用“此规则”来引用该规则，例如 “此规则忽略...”</li>\n<li>将原型代码示例中的箭头与突出显示的构造的开头对齐。</li>\n<li>将原型代码示例中的文本尽量对齐。</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"hljs   language-css\"> @<span class=\"hljs-keyword\">media</span> screen and (min-width: <span class=\"hljs-number\">768px</span>) {}\n<span class=\"hljs-comment\">/**                 ↑          ↑\n  *                  这些名称和值 */</span></code></pre>\n<h4 id=\"单行描述\"><a href=\"#%E5%8D%95%E8%A1%8C%E6%8F%8F%E8%BF%B0\" class=\"phenomic-HeadingAnchor\">#</a>单行描述</h4>\n<p>采取以下形式：</p>\n<ul>\n<li>“禁止...” (对于 <code>no</code> 规则)。</li>\n<li>“限制...” (对于 <code>max</code> 规则)。</li>\n<li>“要求...” (对于接受 <code>\"always\"</code> 和 <code>\"never\"</code> 选项的规则)。</li>\n<li>“指定...” (其他所有)。</li>\n</ul>\n<h4 id=\"示例模式\"><a href=\"#%E7%A4%BA%E4%BE%8B%E6%A8%A1%E5%BC%8F\" class=\"phenomic-HeadingAnchor\">#</a>示例模式</h4>\n<ul>\n<li>使用完整的 CSS 模式，即避免省略号（<code>...</code>）</li>\n<li>默认情况下使用标准 CSS 语法（和 <code>css</code> 受控代码块）。</li>\n<li>使用尽可能少的代码来传达模式，例如如果规则定位于选择器，则使用空规则，例如 <code>{}</code>。</li>\n<li>对于空规则，使用<code>{}</code>而不是<code>{ }</code>。</li>\n<li>默认情况下使用 <code>a</code> 类型选择器。</li>\n<li>默认情况下使用 <code>@media</code> @规则。</li>\n<li>默认情况下使用 <code>color</code> 属性。</li>\n<li>使用 <em>foo</em>、<em>bar</em> 和 <em>baz</em> 作为名称，例如 <code>.foo</code>、<code>#bar</code>、<code>--baz</code></li>\n</ul>\n<h3 id=\"完成规则编写\"><a href=\"#%E5%AE%8C%E6%88%90%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99\" class=\"phenomic-HeadingAnchor\">#</a>完成规则编写</h3>\n<p>最后一步是在以下位置添加对新规则的引用：</p>\n<ul>\n<li><a href=\"https://github.com/stylelint/stylelint/blob/master/lib/rules/index.js\">规则 <code>index.js</code> 文件</a></li>\n<li><a href=\"../../user-guide/rules/\">规则列表</a></li>\n<li><a href=\"../../user-guide/example-config/\">示例配置</a></li>\n</ul>\n<p>一旦您有展示的东西，创建一个<a href=\"https://github.com/stylelint/stylelint/compare\">拉取请求</a>继续讨论。</p>\n<h2 id=\"向现有规则添加选项\"><a href=\"#%E5%90%91%E7%8E%B0%E6%9C%89%E8%A7%84%E5%88%99%E6%B7%BB%E5%8A%A0%E9%80%89%E9%A1%B9\" class=\"phenomic-HeadingAnchor\">#</a>向现有规则添加选项</h2>\n<p>首先，开<a href=\"https://github.com/stylelint/stylelint/issues/new\">一个问题</a>，阐述您想添加的选项。我们将在那里讨论它的功能和名称。</p>\n<p>一旦我们就方向达成一致，您就可以处理拉取请求。以下是您需要采取的步骤：</p>\n<ol>\n<li>运行 <code>npm run watch</code> 以启动交互式测试提示。</li>\n<li>使用 <code>p</code> 命令将活动测试过滤为您正在处理的规则。</li>\n<li>更改规则的验证以允许新选项。</li>\n<li>向规则添加一些逻辑（尽可能少）以使选项有效。</li>\n<li>添加新的单元测试以测试该选项。</li>\n<li>添加有关新选项的文档。</li>\n</ol>\n<h2 id=\"修复现有规则中的-bug\"><a href=\"#%E4%BF%AE%E5%A4%8D%E7%8E%B0%E6%9C%89%E8%A7%84%E5%88%99%E4%B8%AD%E7%9A%84-bug\" class=\"phenomic-HeadingAnchor\">#</a>修复现有规则中的 bug</h2>\n<p>修复错误通常很容易。这是一个有效的过程：</p>\n<ol>\n<li>运行 <code>npm run watch</code> 以启动交互式测试提示。</li>\n<li>使用 <code>p</code> 命令将活动测试过滤为您正在处理的规则。</li>\n<li>编写示例错误的失败单元测试。</li>\n<li>处理规则，直到这些新测试通过。</li>\n</ol>\n<p>就这些！<strong>如果您无法修复 bug，那么在您的测试用例失败的情况下提交拉取请求仍然很有用的。</strong> 这意味着其他人可以直接接手并帮助解决规则的逻辑问题。</p>\n<h2 id=\"弃用规则\"><a href=\"#%E5%BC%83%E7%94%A8%E8%A7%84%E5%88%99\" class=\"phenomic-HeadingAnchor\">#</a>弃用规则</h2>\n<p>弃用规则不会经常发生。但是，这两个步骤很重要：</p>\n<ol>\n<li>将 <code>stylelintReference</code> 链接指向 GitHub 网站上规则自述文档的特定版本，以便始终可以访问它。</li>\n<li>添加适当的元数据以将规则标记为已弃用。</li>\n</ol>\n<h2 id=\"提高规则的性能\"><a href=\"#%E6%8F%90%E9%AB%98%E8%A7%84%E5%88%99%E7%9A%84%E6%80%A7%E8%83%BD\" class=\"phenomic-HeadingAnchor\">#</a>提高规则的性能</h2>\n<p>有一种简单的方法可以在任何给定规则上运行基准测试，并为其提供任何有效配置：</p>\n<pre><code class=\"hljs language-shell\">npm run benchmark-rule -- [rule-name] [config]</code></pre>\n<p>如果 <code>config</code> 参数不是字符串或布尔值，它必须是用引号括起来的有效 JSON。</p>\n<pre><code class=\"hljs language-shell\">npm run benchmark-rule -- selector-combinator-space-after never</code></pre>\n<pre><code class=\"hljs language-shell\">npm run benchmark-rule -- selector-combinator-space-after always</code></pre>\n<pre><code class=\"hljs language-shell\">npm run benchmark-rule -- selector-no-combinator true</code></pre>\n<pre><code class=\"hljs language-shell\">npm run benchmark-rule -- block-opening-brace-space-before \"[\\\"always\\\", {\\\"ignoreAtRules\\\": [\\\"else\\\"]}]\"</code></pre>\n<p>该脚本加载 Bootstrap 的 CSS（来自其 CDN）并通过配置的规则运行它。</p>\n<p>它最终将打印一些简单的统计数据：</p>\n<pre><code class=\"hljs language-shell\">Warnings: 1441\nMean: 74.17598357142856 ms\nDeviation: 16.63969674310928 ms</code></pre>\n<p>您能用这个做什么？ <strong>在编写新规则或重构现有规则时，请使用这些度量来确定代码的效率。</strong></p>\n<p>stylelint 规则会多次重复它的核心逻辑（例如，检查庞大的 CSS 代码库中每个声明的每个值节点）。所以性能值得我们关注并竭尽所能来改进它！</p>\n<p><strong>如果您只想要一个快速的小项目，这是一个很好的贡献方式。</strong> 尝试选择规则并查看是否有任何可以做的事情来加速它。</p>\n<p>确保在拉取请求中包含基准测量！</p>\n","__filename":"developer-guide/rules.md","__url":"/developer-guide/rules/","__resourceUrl":"/developer-guide/rules/index.html","__dataUrl":"/developer-guide/rules/index.html.6c13511d5330393b156567e651e9f75f.json"}